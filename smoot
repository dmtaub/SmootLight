#!/usr/bin/env python

import socket
from time import time as xxxtime
import threading, Queue
from os import system as run
#from numpy import abs,maximum

q=Queue.Queue()

class ConsumerClass(threading.Thread):
  MPERIOD = 1
  def __init__(self,q):
    threading.Thread.__init__(self)
    self.q = q
    self.lastid = None

  def run(self):
   while True:
    datum = self.q.get()
    id = datum['SensorId']
    respt = datum['Responding']
    #diff=xxxtime()-respt
    #if not diff > self.MPERIOD:
    self.lastid = id
    self.q.task_done()

class ProducerClass(threading.Thread):
  def __init__(self,q):
    threading.Thread.__init__(self)
    self.q = q
    HOST = ''
    PORT = 3344
    self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    self.sock.bind((HOST, PORT))

    (self.data,self.address) = self.sock.recvfrom(1024)
    #self.lastt = xxxtime()
    self.addresses = set()

    self.t=ConsumerClass(self.q)
    self.t.setDaemon(True)
    self.t.start()

  def getLast(self):
    return self.t.lastid

  def run(self):
    c=0
    while self.data:
        c+=1
        #dt =( xxxtime()-self.lastt )
        if True: #dt > 1:
    #        print c/dt, " packets per second from", len(addresses), "unique addresses"
            c = 0
            self.addresses = set()
            #self.lastt = xxxtime()
        if 0:#address[-1]=='7':
            print self.parseBinarySensorPacket(self.data)
            #print list(map(parseBinarySensorPacket,data)), '\t', address
        elif 1:
            for datum in self.parseBinarySensorPacket(self.data):
                if type(datum) is dict and datum.has_key('SensorId'):
                   self.q.put(datum)
    #               print 'putting'
        (self.data, self.address) = self.sock.recvfrom(1024)
        self.addresses.add(self.address)

  def grabBits(self,p):
    return bin(ord(p))[2:].zfill(8) 

  def parseBinarySensorPacket(self,p):#, firstBitIndex):
    #print 'starting to parse'
    if len(p) != 5:
        print 'bad length'
    packet = []
    for i,hexByte in enumerate(p):
        bits = self.grabBits(hexByte)
        packet += bits
    output = []
    #print packet
    packet = map(int, packet)
    #print packet
    #print sum(packet)
    #import pdb; pdb.set_trace()
    for j,b in enumerate(packet):
        if b == 1:
            #sensorId = firstBitIndex + i*8 + j
            output.append({'SensorId':j, 'Responding':0})#xxxtime()})
            #print 'responding', j 
        #send output as necessary
    #print 'done parsing'
    return output

p=ProducerClass(q)
p.setDaemon(True)
p.start()
print "debug-module loaded"

#def display(x,y,t):
#  lastid = p.getLast()
#  scaledx = x - min(x)
#  scaledx *= 8 / max(x)
#  scaledx -= .5
#  return [255,255,255] * maximum(1 - abs(lastid-scaledx)[:,None], 0)

from socket import *
from numpy import *

xmit = zeros(174, 'ubyte')
xmit[:8], xmit[20:24] = [4, 1, 220, 74, 1, 0, 8, 1], [150, 0, 255, 15]

def connect(ip, port=6038):
   sock = socket(AF_INET, SOCK_DGRAM, 0)
   sock.connect(('18.224.0.86', 6038))
   return sock

def display(data, sock, chan=1):
   xmit[16], xmit[24:] = chan, minimum(maximum(256 * ravel(pixels), 0), 255)
   sock.sendall(xmit)


